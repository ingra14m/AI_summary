# BFS算法的实例化实现

> 此处的BFS并非深度优先遍历，而是Best-First Search，即A算法

A 算法本质上是图搜索和启发式函数的结合，这个启发式函数可以自己定义，而且具有多样性，没有什么限制。当$h(n) \le h^*(n)$时，A算法优化为A\*算法。



# 本模块说明

本模块描述的问题是将[CBAD]转变为[ABCD]的示例代码。

其中：

- g(n)为从起始点到点n的实际代价（经过的步数，**树中的深度**）
- h(n)为从点n到目标点的估价，本模块的代码采用的是**h(n)为字母不在自己目标位置上的数目**。其实这种写法必定会导致$h(n) \le h^*(n)$，从而使本模块的算法实际上为A\*算法。



# 代码运行详解

前一部分表示当前状态。后一部分表示当前状态的$g(n) + h(n)$

每一次将会找$g(n) + h(n)$值最小的**下一状态**。如果有一样的，则并行的向下进行。如果没有，则此分支终止。

![image-20201113214822187](https://github.com/ingra14m/AI_summary/blob/main/BFS/README.assets/image-20201113214822187.png?raw=true)
